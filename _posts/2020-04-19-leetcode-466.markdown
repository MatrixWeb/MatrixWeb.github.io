**题目**

> https://leetcode-cn.com/problems/count-the-repetitions/
>
> 由 n 个连接的字符串 s 组成字符串 S，记作 S = [s,n]。例如，["abc",3]=“abcabcabc”。
>
> 如果我们可以从 s2 中删除某些字符使其变为 s1，则称字符串 s1 可以从字符串 s2 获得。例如，根据定义，"abc" 可以从 “abdbec” 获得，但不能从 “acbbe” 获得。
>
> 现在给你两个非空字符串 s1 和 s2（每个最多 100 个字符长）和两个整数 0 ≤ n1 ≤ 106 和 1 ≤ n2 ≤ 106。现在考虑字符串 S1 和 S2，其中 S1=[s1,n1] 、S2=[s2,n2] 。
>
> 请你找出一个可以满足使[S2,M] 从 S1 获得的最大整数 M 。
>



题解：

这题确实比较难。

![](img/466_fig1.png)

我们定义 一个循环节，由s1cnt个s1串组成，里面包含s2cnt个s2串。

* 上面这两个变量如何统计

  无非是不断 循环s1，然后移动index，比如当前s1字符和s2的index字符是否一只。如果到达s2末端了就可以把s2++。

  ```c++
  while(1)
          {
              s1cnt++;
              for(char c1:s1)
              { 
                  if(c1==s2[index])
                  {
                      index++;
                      if(index==s2.size())
                      {
                          index=0;
                          s2cnt++;
                      }
                  }
              }
              if(s1cnt==n1)
              {
                  return s2cnt/n2;
              }
          }
  ```

  

* 我们的循环什么时候结束。

  我们要找出循环节的话，就是我们第二次遍历s2的时候就可以找到。

  那样我们定义一个map，key是s2下标。value是当前s1cnt，s2cnt组成的pair。

* 如何计算整个s1中组成s2的个数

  我们把s1当成一个小数3.156789578957895... s2看成是7895

  7895是循环节。

  所以我们第一个统计的pair: <s1cnt , s2cnt>。跟第二次累加的<s1cnt_pri, s2cnt_pri>做差。我们就知道了后面多少个s1可以包含多少个s2。

  最后我们再暴力算出第三部分就行。

```c++
class Solution {
public:
    int getMaxRepetitions(string s1, int n1, string s2, int n2) {
        if(n1==0)
            return 0;
        int s1cnt=0,s2cnt=0;
        int index=0;
        unordered_map<int ,pair<int,int>> recall;
        pair<int ,int> pre,in_loop;
        while(1)
        {
            s1cnt++;
            for(char c1:s1)
            { 
                if(c1==s2[index])
                {
                    index++;
                    if(index==s2.size())
                    {
                        index=0;
                        s2cnt++;
                    }
                }
            }
            if(s1cnt==n1)
            {
                return s2cnt/n2;
            }
            if(recall.count(index))
            {
                pre = recall[index];
                in_loop.first = s1cnt - (pre.first);
                in_loop.second = s2cnt-(pre.second);
                break;
            }else{
                recall[index]={s1cnt,s2cnt};
            }
        }
        int ans = pre.second+(n1-pre.first)/in_loop.first*in_loop.second;
        int rest = (n1-pre.first)%in_loop.first;
        for(int i=0;i<rest;i++)
        {
            for(char ch:s1)
            {
                if(ch == s2[index])
                {
                    index++;
                    if(index == s2.size())
                    {
                        ans++;
                        index=0;
                    }
                }
            }
        }
        return ans/n2;
    }
};
```

